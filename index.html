<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>0.3MP | StarlightGG</title>
    <link rel="icon" type="image/png" href="favicon-96x96.png" sizes="96x96" />
    <style>
        :root {
            --bg: #080808;
            --panel: #111;
            --border: #333;
            --accent: #eee;
            --highlight: #ff0055;
        }


    body {
        margin: 0;
        background-color: var(--bg);
        height: 100vh;
        height: 100dvh;
        display: flex;
        flex-direction: column;
        align-items: center;
        font-family: 'Courier New', Courier, monospace;
        color: var(--accent);
        overflow: hidden;
        user-select: none;
        -webkit-user-select: none;
    }

    .viewport {
        position: relative;
        width: 100%; 
        height: 45vh; 
        min-height: 240px;
        max-width: 100%;
        background: #000;
        border-bottom: 2px solid var(--border);
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        flex-shrink: 0;
    }

    canvas {
        height: 100%;
        width: auto;
        image-rendering: pixelated;
        display: block;
        box-shadow: 0 0 20px rgba(0,0,0,0.5);
    }
    
    .vignette {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        background: radial-gradient(circle, rgba(0,0,0,0) 50%, rgba(20,0,10,0.1) 85%, rgba(0,0,0,0.85) 100%);
        pointer-events: none;
        z-index: 5;
    }

    .overlay {
        position: absolute;
        top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.95);
        z-index: 50;
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 15px;
        padding: 20px;
        text-align: center;
    }

    .overlay h2 { margin: 0; color: var(--highlight); font-size: 18px; text-transform: uppercase; border-bottom: 1px solid var(--highlight); padding-bottom: 5px; }

    .controls {
        flex-grow: 1;
        width: 100%;
        max-width: 430px;
        background: #000;
        padding: 12px;
        padding-bottom: 30px; 
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        gap: 8px;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        overscroll-behavior: contain;
    }

    .row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
    }

    button, select {
        background: #2c2c2e;
        color: #fff;
        border: none;
        padding: 10px 12px;
        font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', 'Segoe UI', sans-serif;
        font-size: 13px;
        cursor: pointer;
        flex-grow: 1;
        text-transform: none;
        font-weight: 600;
        border-radius: 10px;
        min-width: 0;
        -webkit-appearance: none;
        box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        transition: all 0.1s ease;
    }
    button:active { 
        background: #3a3a3c; 
        transform: scale(0.98);
    }

    select {
        text-align: center;
        text-align-last: center;
        background-image: linear-gradient(45deg, transparent 50%, #888 50%), linear-gradient(135deg, #888 50%, transparent 50%);
        background-position: calc(100% - 12px) calc(1em + 2px), calc(100% - 7px) calc(1em + 2px);
        background-size: 5px 5px, 5px 5px;
        background-repeat: no-repeat;
        padding-right: 24px;
    }

    #settingsToggle {
        width: 100%;
        background: #1c1c1e;
        color: #666;
        border: 1px solid #333;
        margin: 5px 0;
        text-align: center;
        font-size: 10px;
        letter-spacing: 2px;
        padding: 10px;
        border-radius: 8px;
        transition: all 0.2s;
        font-weight: 800;
    }

    #settingsPanel {
        max-height: 0;
        overflow: hidden;
        opacity: 0;
        transform: scaleY(0.8) translateY(-20px);
        transform-origin: top center;
        transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1); 
        display: flex;
        flex-direction: column;
        gap: 8px;
        padding: 0 2px;
    }

    #settingsPanel.open {
        max-height: 1200px;
        opacity: 1;
        transform: scaleY(1) translateY(0);
        margin-bottom: 10px;
        padding-top: 5px;
        overflow: visible;
    }

    .controls-bottom {
        margin-top: auto;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 15px;
        width: 100%;
        padding-bottom: 5px;
    }

    .mode-switch {
        display: flex;
        background: #2c2c2e;
        border-radius: 20px;
        padding: 4px;
        box-shadow: inset 0 1px 3px rgba(0,0,0,0.5);
    }

    .mode-option {
        padding: 8px 24px;
        font-size: 11px;
        font-weight: 700;
        color: #888;
        cursor: pointer;
        border-radius: 16px;
        transition: all 0.2s ease;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }
    
    .mode-option.active {
        color: #000;
        background: var(--accent);
        box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }

    #shutterBtn {
        width: 72px;
        height: 72px;
        border-radius: 50%;
        border: 4px solid #fff;
        background: transparent;
        padding: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        transition: transform 0.1s;
        position: relative;
        flex-grow: 0;
    }
    
    #shutterBtn:active { transform: scale(0.95); }
    #shutterInner {
        width: 58px;
        height: 58px;
        border-radius: 50%;
        background: #fff;
        transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }
    .video-mode #shutterInner { background: #ff3b30; }
    #shutterBtn.recording { border-color: rgba(255, 255, 255, 0.5); }
    #shutterBtn.recording #shutterInner {
        background: #ff3b30;
        width: 28px; height: 28px;
        border-radius: 4px;
    }

    .slider-group {
        display: flex;
        flex-direction: column;
        gap: 4px;
        background: #2c2c2e;
        padding: 8px 12px;
        border-radius: 10px;
    }
    .slider-label { font-size: 11px; color: #98989d; display: flex; justify-content: space-between; font-weight: 500;}
    input[type=range] { 
        width: 100%; 
        accent-color: var(--highlight); 
        height: 6px; 
        margin: 4px 0;
        -webkit-appearance: none;
        background: #48484a;
        border-radius: 3px;
        outline: none;
    }
    input[type=range]::-webkit-slider-thumb {
        -webkit-appearance: none; width: 20px; height: 20px;
        border-radius: 50%; background: white; cursor: pointer;
        box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }

    .custom-ui-panel {
        display: none;
        flex-direction: column;
        gap: 8px;
        background: #2c2c2e;
        padding: 10px;
        border-radius: 10px;
    }
    
    input[type=text] {
        background: #1c1c1e;
        border: none;
        color: #fff;
        padding: 8px 10px;
        width: 100%;
        box-sizing: border-box;
        text-transform: uppercase;
        font-size: 12px;
        border-radius: 8px;
    }

    #fileInput { display: none; }

    #status {
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0,0,0,0.8);
        padding: 10px 20px;
        border: 1px solid #555;
        z-index: 100;
        display: none;
        color: white;
        pointer-events: none;
        text-align: center;
    }

    #startScreen {
        position: absolute;
        top: 0; left: 0; right: 0; bottom: 0;
        background: #000;
        z-index: 200;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
    }
    #startBtn {
        font-size: 20px;
        padding: 15px 30px;
        border: 2px solid var(--highlight);
        color: var(--highlight);
        background: transparent;
        animation: pulse 2s infinite;
        flex-grow: 0;
    }
    @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.7; } 100% { opacity: 1; } }

    video::-webkit-media-controls { display: none !important; }
    video::-webkit-media-controls-play-button { display: none !important; }
    video::-webkit-media-controls-start-playback-button { display: none !important; }
</style>


</head>
<body oncontextmenu="event.preventDefault();">


<div id="startScreen">
    <button id="startBtn">TAP TO START</button>
    <div style="margin-top:20px; color:#666; font-size:12px;">ALLOW CAMERA ACCESS</div>
</div>

<div id="resumeOverlay" class="overlay" style="display:none; z-index: 60;">
    <h2>SESSION PAUSED</h2>
    <div style="font-size:12px; color:#ccc; margin-bottom:15px;">TAP TO RESTART CAMERA & MIC</div>
    <button id="resumeBtn" style="font-size:16px; padding:15px 30px; border-color:var(--highlight); color:var(--highlight);">RESUME</button>
</div>

<div id="cameraFailOverlay" class="overlay" style="display:none;">
    <h2 style="color:#ff0055;">CAMERA FAILED</h2>
    <div style="font-size:14px; color:#ccc; margin:10px 0;">UNABLE TO ACCESS CAMERA</div>
    <button id="retryCamera" style="font-size:16px; padding:15px 30px; border-color:var(--highlight); color:var(--highlight);">RETRY</button>
</div>

<div class="viewport">
    <canvas id="canvas"></canvas>
    <div class="vignette"></div>
    <div id="status">INITIALIZING...</div>
</div>

<video id="video" playsinline webkit-playsinline muted crossorigin="anonymous" style="display:none;"></video>
<input type="file" id="fileInput" accept="video/*,image/*">

<div class="controls">
    <div class="row">
        <button id="sourceBtn" onclick="playSound('click')">SRC: CAM</button>
        <button id="flipBtn" onclick="playSound('click')">FLIP CAM</button>
        <button id="flashBtn" onclick="toggleFlash()" style="display:none;">FLASH</button>
        <button id="invertBtn" onclick="playSound('click')">MIRROR</button>
    </div>
    
    <button id="settingsToggle" onclick="toggleSettings()">▼ OPTIONS ▼</button>

    <div id="settingsPanel">
        <div class="row">
            <select id="modeSelect" onclick="playSound('click')"></select>
            <select id="formatSelect" onclick="playSound('click')">
                <option value="auto">AUTO FMT (IOS SAFE)</option>
            </select>
        </div>

        <div class="slider-group">
            <div class="slider-label"><span>DIGITAL ZOOM</span> <span id="zoomDisplay">1.0x</span></div>
            <input type="range" id="zoomRange" min="10" max="75" value="10" oninput="playSound('tick')">
        </div>

        <div class="slider-group">
            <div class="slider-label"><span>LENS BLUR</span> <span>OUTLINE (RGB)</span></div>
            <input type="range" id="blurRange" min="0" max="60" value="0" oninput="playSound('tick')">
            <input type="range" id="ghostRange" min="0" max="100" value="20" oninput="playSound('tick')">
        </div>

        <div class="slider-group">
            <div class="slider-label"><span>TEAR / LAG (GHOSTING)</span></div>
            <input type="range" id="lagRange" min="0" max="100" value="20" oninput="playSound('tick')">
        </div>

        <div class="slider-group">
            <div class="slider-label"><span>CONTRAST</span> <span>QUALITY (JPEG)</span></div>
            <div style="display:flex; gap:5px;">
                <input type="range" id="contrastRange" min="0" max="100" value="50" oninput="playSound('tick')">
                <input type="range" id="qualityRange" min="0" max="100" value="50" oninput="playSound('tick')">
            </div>
        </div>

        <div id="vhsControls" class="custom-ui-panel">
            <div class="ui-label">VHS OVERLAY</div>
            <input type="text" id="vhsText" value="PLAY >">
            <div style="display:flex; gap:5px; margin-top:4px;">
                <input type="text" id="vhsDateInput" value="AUTO" style="flex-grow:2">
                <input type="text" id="vhsSpeedInput" value="AUTO" style="width: 40px; text-align:center;">
            </div>
            <div class="slider-label" style="margin-top:4px;">TRACKING NOISE</div>
            <input type="range" id="trackingRange" min="0" max="100" value="15" oninput="playSound('tick')">
        </div>
    </div>

    <div class="controls-bottom">
        <div class="mode-switch" id="modeSwitch">
            <div class="mode-option active" id="modePhoto" onclick="switchMode('photo')">PHOTO</div>
            <div class="mode-option" id="modeVideo" onclick="switchMode('video')">VIDEO</div>
        </div>
        <button id="shutterBtn" onclick="handleShutter()">
            <div id="shutterInner"></div>
        </button>
    </div>
</div>

<script>
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true, alpha: false });
    
    // CRITICAL FIX: Recording canvas matches display resolution
    const recCanvas = document.createElement('canvas');
    const recCtx = recCanvas.getContext('2d', { alpha: false, desynchronized: true });
    recCtx.imageSmoothingEnabled = false;
    
    const startScreen = document.getElementById('startScreen');
    const startBtn = document.getElementById('startBtn');
    const sourceBtn = document.getElementById('sourceBtn');
    const flipBtn = document.getElementById('flipBtn');
    const invertBtn = document.getElementById('invertBtn');
    const flashBtn = document.getElementById('flashBtn');
    const fileInput = document.getElementById('fileInput');
    const modeSelect = document.getElementById('modeSelect');
    const formatSelect = document.getElementById('formatSelect');
    const shutterBtn = document.getElementById('shutterBtn');
    const modeSwitch = document.getElementById('modeSwitch');
    const modePhoto = document.getElementById('modePhoto');
    const modeVideo = document.getElementById('modeVideo');
    const settingsToggle = document.getElementById('settingsToggle');
    const settingsPanel = document.getElementById('settingsPanel');
    const status = document.getElementById('status');
    const vhsControls = document.getElementById('vhsControls');
    const zoomDisplay = document.getElementById('zoomDisplay');
    const resumeOverlay = document.getElementById('resumeOverlay');
    const resumeBtn = document.getElementById('resumeBtn');
    const cameraFailOverlay = document.getElementById('cameraFailOverlay');
    const retryCamera = document.getElementById('retryCamera');

    const zoomRange = document.getElementById('zoomRange');
    const blurRange = document.getElementById('blurRange');
    const ghostRange = document.getElementById('ghostRange');
    const lagRange = document.getElementById('lagRange');
    const contrastRange = document.getElementById('contrastRange');
    const qualityRange = document.getElementById('qualityRange');
    const vhsTextIn = document.getElementById('vhsText');
    const vhsDateIn = document.getElementById('vhsDateInput');
    const vhsSpeedIn = document.getElementById('vhsSpeedInput');
    const trackingRange = document.getElementById('trackingRange');

    let w = 352; let h = 416;
    
    let tempC = document.createElement('canvas'); let tempCtx = tempC.getContext('2d');
    let processedC = document.createElement('canvas'); let pCtx = processedC.getContext('2d');
    let tearC = document.createElement('canvas'); let tearCtx = tearC.getContext('2d');
    let noiseCanvas = document.createElement('canvas'); let nCtx = noiseCanvas.getContext('2d');

    let sourceType = 'camera'; 
    let isRecording = false;
    let isMirrored = false;
    let mediaRecorder;
    let recordedChunks = [];
    let modeIndex = 0;
    let audioStreamDestination = null; 
    let currentStream = null;
    let noiseNode = null;
    let videoSourceNode = null;
    let currentFacingMode = 'environment';
    let audioCtx;
    let uploadedImage = null;
    let captureMode = 'photo'; 
    let isFlashOn = false;
    let keepAliveOsc = null;
    
    let lastFrameTime = 0;
    const FPS = 25; // CRITICAL: 25 FPS for universal mobile/desktop compatibility
    const FRAME_INTERVAL = 1000 / FPS;
    let exposureGain = 1.0;
    let shutterPhase = 0;
    let lcdDelayBuffer = null;
    let rollingShutterBuffer = null;
    let lastTearTime = 0;
    let shockStress = 0;
    let wbHuntPhase = 0;
    let wbHuntStrength = 1.0; 

    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    const modes = [
        { name: "NOKIA 7650", type: "phone", w: 176, h: 208, sensor: {w: 480, h: 640}, squeeze: 1.0, r:0.92, g:1.08, b:0.92, con:1.1, sat: 0.95, crush: 20, blow: 240, banding: 16, lagMult: 0.8, colorCycle: true, cycleSpeed: 0.2, cycleAmp: 0.35, aeTarget: 110, def: {blur:2, ghost:10, track:0, quality: 65, contrast: 55}, audio: {hp: 300, lp: 3400, noise: 0.04, dist: 50} },
        { name: "NOKIA 6600", type: "phone", w: 176, h: 208, sensor: {w: 480, h: 640}, squeeze: 0.94, r:0.95, g:1.0, b:0.88, con:1.05, sat: 1.05, crush: 18, blow: 242, banding: 12, lagMult: 0.6, colorCycle: true, cycleSpeed: 0.15, cycleAmp: 0.25, aeTarget: 128, def: {blur:3, ghost:8, track:0, quality: 75, contrast: 50}, audio: {hp: 300, lp: 3400, noise: 0.03, dist: 35} },
        { name: "SIEMENS CX65", type: "phone", w: 132, h: 176, sensor: {w: 480, h: 640}, squeeze: 0.90, r:1.05, g:1.05, b:0.9, con:1.1, sat: 0.85, crush: 25, blow: 220, banding: 32, lagMult: 2.0, colorCycle: true, cycleSpeed: 0.25, cycleAmp: 0.4, aeTarget: 128, def: {blur:3.5, ghost:25, track:0, quality: 55, contrast: 60}, audio: {hp: 400, lp: 3400, noise: 0.05, dist: 80} },
        { name: "SIEMENS CX70", type: "phone", w: 132, h: 176, sensor: {w: 480, h: 640}, squeeze: 0.90, r:1.03, g:1.05, b:0.92, con:1.1, sat: 0.88, crush: 22, blow: 225, banding: 24, lagMult: 1.3, colorCycle: true, cycleSpeed: 0.22, cycleAmp: 0.35, aeTarget: 110, def: {blur:3, ghost:18, track:0, quality: 60, contrast: 60}, audio: {hp: 400, lp: 3400, noise: 0.045, dist: 70} },
        { name: "MOTO RAZR V3",  type: "phone", w: 176, h: 220, sensor: {w: 480, h: 640}, squeeze: 1.0, r:0.9, g:0.95, b:1.25, con:1.3, sat: 0.75, crush: 35, blow: 230, banding: 32, lagMult: 0.6, colorCycle: false, aeTarget: 120, def: {blur:3, ghost:5, track:0, quality: 40, contrast: 65}, audio: {hp: 300, lp: 3400, noise: 0.03, dist: 30} },
        { name: "SAMSUNG E700", type: "phone", w: 128, h: 160, sensor: {w: 480, h: 640}, squeeze: 0.95, r:0.98, g:0.95, b:1.05, con:1.05, sat: 1.0, crush: 20, blow: 235, banding: 16, lagMult: 0.7, colorCycle: false, aeTarget: 125, def: {blur:2, ghost:10, track:0, quality: 45, contrast: 55}, audio: {hp: 350, lp: 3400, noise: 0.03, dist: 40} },
        { name: "SONY K750",  type: "phone", w: 176, h: 220, sensor: {w: 1224, h: 1632}, squeeze: 1.0, r:1.15, g:1.02, b:0.85, con:1.0, sat: 1.2, crush: 10, blow: 250, banding: 8, lagMult: 0.5, colorCycle: false, aeTarget: 130, def: {blur:1, ghost:5, track:0, quality: 60, contrast: 52}, audio: {hp: 150, lp: 8000, noise: 0.02, dist: 20} },
        { name: "SHARP GX30",   type: "phone", w: 240, h: 320, sensor: {w: 858, h: 1144}, squeeze: 1.0, r:1.1, g:0.95, b:1.0, con:1.2, sat: 1.4, crush: 15, blow: 245, banding: 8, lagMult: 0.3, colorCycle: false, aeTarget: 130, def: {blur:0, ghost:0, track:0, quality: 65, contrast: 58}, audio: {hp: 300, lp: 3400, noise: 0.02, dist: 25} },
        { name: "PALM TREO 680",  type: "phone", w: 320, h: 320, sensor: {w: 640, h: 480}, squeeze: 1.0, r:0.95, g:1.05, b:0.95, con:0.95, sat: 0.75, crush: 10, blow: 220, banding: 32, lagMult: 1.8, colorCycle: true, cycleSpeed: 0.18, cycleAmp: 0.3, aeTarget: 100, def: {blur:4, ghost:25, track:0, quality: 47, contrast: 45}, audio: {hp: 400, lp: 3000, noise: 0.06, dist: 100} },
        { name: "NOKIA N95",  type: "phone", w: 240, h: 320, sensor: {w: 1944, h: 2592}, squeeze: 1.0, r:1.05, g:1.02, b:0.93, con:1.08, sat: 1.15, crush: 8, blow: 245, banding: 6, lagMult: 0.4, colorCycle: false, aeTarget: 128, def: {blur:1, ghost:5, track:0, quality: 80, contrast: 50}, audio: {hp: 100, lp: 12000, noise: 0.015, dist: 18} },
        { name: "VHS TAPE",   type: "vhs",   w: 640, h: 480, sensor: {w: 640, h: 480}, squeeze: 1.0, r:1.05, g:0.95, b:0.9, con:1.1, sat: 0.95, crush: 15, blow: 235, banding: 4, lagMult: 1.2, colorCycle: false, aeTarget: 128, def: {blur:2, ghost:25, track:15, quality: 65, contrast: 60}, audio: {hp: 50, lp: 10000, noise: 0.06, dist: 60} },
        { name: "SENSOR RAW", type: "raw",   w: 640, h: 480, sensor: {w: 640, h: 480}, squeeze: 1.0, r:1.0, g:1.0, b:1.0, con:1.0, sat: 1.0, crush: 0, blow: 255, banding: 1, lagMult: 1.5, colorCycle: false, aeTarget: 128, def: {blur:0, ghost:30, lag:70, track:0, quality: 100, contrast: 50}, audio: {hp: 20, lp: 20000, noise: 0.01, dist: 0} }
    ];

    function resizeBuffers() {
        canvas.width = w; canvas.height = h;
        tempC.width = w; tempC.height = h; tempCtx = tempC.getContext('2d');
        processedC.width = w; processedC.height = h; pCtx = processedC.getContext('2d');
        tearC.width = w; tearC.height = h; tearCtx = tearC.getContext('2d');
        
        noiseCanvas.width = w; noiseCanvas.height = h; nCtx = noiseCanvas.getContext('2d');
        const nID = nCtx.createImageData(w, h);
        for(let i=0; i<nID.data.length; i+=4) {
            if (Math.random() > 0.995) {
                const val = Math.random() * 40; 
                nID.data[i] = val; nID.data[i+1] = val; nID.data[i+2] = val; 
                nID.data[i+3] = Math.random() * 30; 
            }
        }
        nCtx.putImageData(nID, 0, 0);
        lcdDelayBuffer = null;
        rollingShutterBuffer = null; 
        shutterPhase = 0;
        
        // CRITICAL: Recording canvas matches display
        recCanvas.width = w;
        recCanvas.height = h;
    }
    resizeBuffers();

    function initAudio() { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
    
    function makeDistortionCurve(amount) {
        const k = typeof amount === 'number' ? amount : 50;
        const n_samples = 44100; const curve = new Float32Array(n_samples); const deg = Math.PI / 180;
        for (let i = 0; i < n_samples; ++i) {
            const x = i * 2 / n_samples - 1;
            curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
        }
        return curve;
    }

    function playSound(type) {
        if (!audioCtx) return;
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain); gain.connect(audioCtx.destination); 
        const now = audioCtx.currentTime;
        
        if (type === 'click') {
            osc.type = 'square'; osc.frequency.setValueAtTime(800, now); osc.frequency.exponentialRampToValueAtTime(400, now + 0.05);
            gain.gain.setValueAtTime(0.05, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
            osc.start(now); osc.stop(now + 0.05);
        } else if (type === 'tick') {
            osc.type = 'triangle'; osc.frequency.setValueAtTime(1200, now);
            gain.gain.setValueAtTime(0.02, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.02);
            osc.start(now); osc.stop(now + 0.02);
        } else if (type === 'shutter') {
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(200, now); osc.frequency.linearRampToValueAtTime(100, now + 0.1);
            gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0.001, now + 0.1);
            osc.start(now); osc.stop(now + 0.1);
        }
    }

    modes.forEach((m, i) => {
        const opt = document.createElement('option'); opt.value = i; opt.text = m.name; modeSelect.appendChild(opt);
    });

    const allFormats = [
        { val: 'image/jpeg', label: 'JPG IMAGE' },
        { val: 'image/png', label: 'PNG IMAGE' },
        { val: 'video/webm', label: 'WEBM VIDEO' },
        { val: 'video/mp4', label: 'MP4 VIDEO' }
    ];
    allFormats.forEach(fmt => {
        const opt = document.createElement('option'); opt.value = fmt.val; opt.text = fmt.label; formatSelect.appendChild(opt);
    });

    startBtn.onclick = () => { startScreen.style.display = 'none'; initAudio(); startCamera(); };
    resumeBtn.onclick = () => { playSound('click'); resumeOverlay.style.display = 'none'; startCamera(); };
    retryCamera.onclick = () => { playSound('click'); cameraFailOverlay.style.display = 'none'; startCamera(); };

    let pauseTimeout = null;

    function triggerPause() {
        const isRunning = startScreen.style.display === 'none';
        
        if (sourceType === 'camera' && isRunning) {
            stopCamera();
            resumeOverlay.style.display = 'flex';
        }
    }

    document.addEventListener("visibilitychange", () => {
        if (document.visibilityState === 'hidden') {
            if (pauseTimeout) clearTimeout(pauseTimeout);
            pauseTimeout = setTimeout(triggerPause, 15000);
        } else {
            if (pauseTimeout) clearTimeout(pauseTimeout);
        }
    });

    window.addEventListener("blur", () => {
        if (pauseTimeout) clearTimeout(pauseTimeout);
        pauseTimeout = setTimeout(triggerPause, 15000);
    });
    
    window.addEventListener("focus", () => {
        if (pauseTimeout) clearTimeout(pauseTimeout);
    });

    function stopCamera() {
        if (currentStream) { 
            const track = currentStream.getVideoTracks()[0];
            if (isFlashOn && track) {
                try { track.applyConstraints({ advanced: [{ torch: false }] }); } catch(e){}
            }
            currentStream.getTracks().forEach(t => t.stop()); 
            currentStream = null; 
        }
        video.srcObject = null;
        if (flashBtn) {
            flashBtn.style.display = 'none';
            isFlashOn = false;
        }
    }

    function toggleSettings() {
        playSound('click');
        settingsPanel.classList.toggle('open');
        settingsToggle.innerText = settingsPanel.classList.contains('open') ? "▲ HIDE ▲" : "▼ OPTIONS ▼";
    }

    function switchMode(mode) {
        playSound('click');
        captureMode = mode;
        modePhoto.classList.toggle('active', mode === 'photo');
        modeVideo.classList.toggle('active', mode === 'video');
        document.body.classList.toggle('video-mode', mode === 'video');
    }

    function resetToCamera() {
        if (isRecording) stopRecording();
        video.pause(); video.src = ""; video.loop = false; video.onended = null;
        uploadedImage = null; sourceType = 'camera';
        sourceBtn.innerText = "SRC: CAM";
        if(flashBtn) flashBtn.style.display = 'none';
        modeSwitch.style.display = 'flex'; 
        modePhoto.style.display = 'block';
        modeVideo.style.display = 'block';
        shutterBtn.classList.remove("recording");
        startCamera();
    }

    sourceBtn.onclick = () => {
        playSound('click');
        if (sourceType === 'camera') fileInput.click();
        else resetToCamera();
    };
    
    invertBtn.onclick = () => {
        playSound('click');
        isMirrored = !isMirrored;
    };
    
    fileInput.onchange = (e) => { processImportFile(e.target.files[0]); };
    
    function processImportFile(file) {
        if (!file) return;
        resumeOverlay.style.display = 'none'; 

        stopCamera();
        const url = URL.createObjectURL(file);
        sourceBtn.innerText = "CANCEL";
        
        modeSwitch.style.display = 'flex';
        
        if (file.type.startsWith('image/')) {
            modeVideo.style.display = 'none';
            modePhoto.style.display = 'block';
            switchMode('photo');

            uploadedImage = new Image();
            uploadedImage.onload = () => { sourceType = 'image'; video.src = ""; };
            uploadedImage.src = url;
        } else {
            modePhoto.style.display = 'none';
            modeVideo.style.display = 'block';
            switchMode('video');

            uploadedImage = null; video.srcObject = null; video.src = url;
            sourceType = 'video'; video.loop = false;
            video.onloadedmetadata = () => {
                video.muted = false; video.volume = 1.0;
                if (!videoSourceNode && audioCtx) videoSourceNode = audioCtx.createMediaElementSource(video);
                initAudioProcessing(null, videoSourceNode);
                video.currentTime = 0;
                video.pause(); 
            };
            video.onended = () => {
                if (isRecording) stopRecording();
            };
        }
    }

    function showStatus(msg, isError = false) {
        status.style.display = 'block';
        status.style.color = isError ? '#ff0055' : 'white';
        status.innerHTML = msg;
        if (isError) setTimeout(() => { status.style.display = 'none'; status.style.color = 'white'; }, 2000);
    }

    async function startCamera(retryStage = 0) {
        status.style.display = 'block'; status.innerText = "FINDING CAMERA...";
        sourceType = 'camera'; sourceBtn.innerText = "SRC: CAM";
        
        try {
            stopCamera();
            const constraints = { video: { facingMode: currentFacingMode, width: { ideal: 640 } }, audio: true };
            if (retryStage === 2) constraints.audio = false;

            const stream = await navigator.mediaDevices.getUserMedia(constraints);
            
            const hasVideo = stream.getVideoTracks().length > 0;
            const hasAudio = stream.getAudioTracks().length > 0;
            
            if (retryStage < 2 && constraints.audio && !hasAudio && hasVideo) {
                stream.getTracks().forEach(t => t.stop());
                setTimeout(() => startCamera(2), 300);
                return;
            }

            const track = stream.getVideoTracks()[0];
            if (track) {
                const caps = track.getCapabilities();
                if (caps && caps.torch) {
                    flashBtn.style.display = 'block';
                    flashBtn.innerText = "FLASH";
                    flashBtn.style.color = "#fff";
                    isFlashOn = false;
                } else {
                    flashBtn.style.display = 'none';
                }
            }

            currentStream = stream; video.srcObject = stream; video.muted = true;
            video.onloadedmetadata = () => {
                video.play().then(() => {
                    status.style.display = 'none'; cameraFailOverlay.style.display = 'none';
                    if (stream.getAudioTracks().length > 0) initAudioProcessing(stream);
                });
            };
        } catch (err) {
            if (retryStage === 0) setTimeout(() => startCamera(1), 500);
            else if (retryStage === 1) startCamera(2);
            else { status.style.display = 'none'; cameraFailOverlay.style.display = 'flex'; }
        }
    }

    flipBtn.onclick = async () => {
        if (sourceType !== 'camera') return;
        playSound('click');
        currentFacingMode = (currentFacingMode === 'environment') ? 'user' : 'environment';
        
        const oldVideoTrack = currentStream ? currentStream.getVideoTracks()[0] : null;
        
        try {
            const newVideoStream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: currentFacingMode, width: { ideal: 640 } },
                audio: false
            });
            
            const newVideoTrack = newVideoStream.getVideoTracks()[0];
            
            if (currentStream) {
                if (oldVideoTrack) oldVideoTrack.stop();
                currentStream.getVideoTracks().forEach(track => currentStream.removeTrack(track));
                currentStream.addTrack(newVideoTrack);
                
                video.srcObject = null;
                video.srcObject = currentStream;
                
                const caps = newVideoTrack.getCapabilities();
                if (caps && caps.torch) {
                    flashBtn.style.display = 'block';
                    isFlashOn = false;
                    flashBtn.innerText = "FLASH";
                    flashBtn.style.color = "#fff";
                } else {
                    flashBtn.style.display = 'none';
                }
                
                video.onloadedmetadata = () => {
                    video.play().catch(e => console.log(e));
                };
            }
        } catch (err) {
            console.error("Flip failed:", err);
            startCamera();
        }
    };

    async function toggleFlash() {
        if (!currentStream) return;
        const track = currentStream.getVideoTracks()[0];
        if (!track) return;
        
        isFlashOn = !isFlashOn;
        
        try {
            await track.applyConstraints({ advanced: [{ torch: isFlashOn }] });
            flashBtn.innerText = isFlashOn ? "FLASH: ON" : "FLASH";
            flashBtn.style.color = isFlashOn ? "var(--highlight)" : "#fff";
            playSound('click');
        } catch (err) {
            isFlashOn = !isFlashOn;
            flashBtn.innerText = "ERR";
            setTimeout(() => { flashBtn.innerText = "FLASH"; }, 1000);
        }
    }

    function initAudioProcessing(stream, elementSource = null) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        if (noiseNode) { try { noiseNode.stop(); } catch(e){} noiseNode.disconnect(); }
        if (keepAliveOsc) { try { keepAliveOsc.stop(); } catch(e){} keepAliveOsc.disconnect(); }
        if (audioStreamDestination) audioStreamDestination.disconnect();

        audioStreamDestination = audioCtx.createMediaStreamDestination();

        const silentOsc = audioCtx.createOscillator();
        const silentGain = audioCtx.createGain();
        silentOsc.type = 'sine';
        silentOsc.frequency.value = 440;
        silentGain.gain.value = 0.0001;
        silentOsc.connect(silentGain);
        silentGain.connect(audioStreamDestination);
        silentOsc.start();
        keepAliveOsc = silentOsc;

        let source = elementSource || audioCtx.createMediaStreamSource(stream);
        
        const mode = modes[modeIndex];
        const settings = mode.audio || {hp: 300, lp: 3500, noise: 0.001, dist: 0};

        const hp = audioCtx.createBiquadFilter(); hp.type = 'highpass'; hp.frequency.value = settings.hp;
        const lp = audioCtx.createBiquadFilter(); lp.type = 'lowpass'; lp.frequency.value = settings.lp;
        const dist = audioCtx.createWaveShaper(); dist.curve = makeDistortionCurve(settings.dist);
        const comp = audioCtx.createDynamicsCompressor();
        comp.threshold.value = -20; comp.ratio.value = 12;

        const bSize = audioCtx.sampleRate * 2; 
        const b = audioCtx.createBuffer(1, bSize, audioCtx.sampleRate);
        const d = b.getChannelData(0);
        for (let i = 0; i < bSize; i++) d[i] = (Math.random() * 2 - 1);
        
        noiseNode = audioCtx.createBufferSource();
        noiseNode.buffer = b; noiseNode.loop = true;
        const nGain = audioCtx.createGain(); nGain.gain.value = settings.noise;
        noiseNode.connect(nGain); nGain.connect(comp);
        
        source.connect(hp); hp.connect(dist); dist.connect(lp); lp.connect(comp);
        
        comp.connect(audioStreamDestination);
        noiseNode.start();
    }

    function render(time) {
        requestAnimationFrame(render);
        if (!lastFrameTime) lastFrameTime = time;
        const elapsed = time - lastFrameTime;
        if (elapsed < FRAME_INTERVAL) return;
        lastFrameTime = time - (elapsed % FRAME_INTERVAL);

        if (sourceType === 'video' || (video.readyState >= 2 && sourceType !== 'image') || (sourceType === 'image' && uploadedImage)) {
            const mode = modes[modeIndex];
            
            tempC.width = w; tempC.height = h;
            if (isMirrored) { tempCtx.translate(w, 0); tempCtx.scale(-1, 1); }
            
            if (sourceType === 'image' && uploadedImage) {
                const ratio = Math.max(w / uploadedImage.width, h / uploadedImage.height);
                const sw = uploadedImage.width * ratio * (zoomRange.value/10); 
                const sh = uploadedImage.height * ratio * (zoomRange.value/10) * mode.squeeze;
                
                tempCtx.clearRect(0, 0, w, h);
                tempCtx.drawImage(uploadedImage, (w-sw)/2, (h-sh)/2, sw, sh);
            } else {
                const z = zoomRange.value / 10;
                const vW = video.videoWidth; const vH = video.videoHeight;
                const tW = w; const tH = h * mode.squeeze;
                const sH = (vH < vW * (tH/tW)) ? vH : vW * (tH/tW);
                const sW = sH * (tW/tH);
                tempCtx.drawImage(video, (vW-sW/z)/2, (vH-sH/z)/2, sW/z, sH/z, 0, (h-tH)/2, tW, tH);
            }

            const srcData = tempCtx.getImageData(0, 0, w, h);
            const dSrc = srcData.data;
            const output = ctx.createImageData(w, h);
            const dOut = output.data;

            let totalBright = 0;
            let maxBright = 0;
            for(let i=0; i<dSrc.length; i+=64) {
                const b = (dSrc[i]+dSrc[i+1]+dSrc[i+2])/3;
                totalBright += b;
                if(b > maxBright) maxBright = b;
            }
            const avgBright = totalBright / (dSrc.length/64);
            
            let targetGain = (mode.aeTarget || 128) / (avgBright + 1);
            if (maxBright > 250) { targetGain *= 0.88; }

            if (exposureGain > targetGain * 1.5) shockStress = Math.min(shockStress + 0.05, 1.0);
            else shockStress = Math.max(shockStress - 0.01, 0);
            
            exposureGain += (targetGain - exposureGain) * 0.04;
            exposureGain = Math.max(0.2, Math.min(3.5, exposureGain));

            let rBias = 0, bBias = 0;
            if (mode.colorCycle) {
                wbHuntStrength = Math.max(0, wbHuntStrength - 0.008);
                
                if (exposureGain > 2.0 || exposureGain < 0.5) {
                    if (wbHuntStrength < 0.5) wbHuntStrength = 0.5;
                }
                
                if (wbHuntStrength <= 0 && Math.random() > 0.99) {
                    wbHuntStrength = 1.0;
                }
                
                const huntSpeed = mode.cycleSpeed || 0.15;
                const huntAmp = (mode.cycleAmp || 0.25) * wbHuntStrength; 
                
                wbHuntPhase += huntSpeed;
                rBias = Math.sin(wbHuntPhase) * huntAmp;
                bBias = Math.cos(wbHuntPhase) * huntAmp;
            } else {
                wbHuntStrength = 0; 
            }

            const shift = Math.floor(ghostRange.value / 8);
            const conVal = parseInt(contrastRange.value);
            const qVal = parseInt(qualityRange.value);
            
            const crushMod = (conVal - 50) * 0.6; 
            const activeCrush = Math.max(0, Math.min(70, mode.crush + crushMod));
            const blowMod = (conVal - 50) * 0.6;
            const activeBlow = Math.max(180, Math.min(255, mode.blow - blowMod));
            
            let activeBanding = mode.banding;
            if (qVal > 50) activeBanding = Math.max(1, Math.floor(mode.banding * (1 - (qVal-50)/50)));

            for (let i = 0; i < dSrc.length; i += 4) {
                const iLeft = Math.max(0, i - shift*4);
                const iRight = Math.min(dSrc.length-4, i + shift*4);

                let r = dSrc[iLeft];
                let g = dSrc[i+1];
                let b = dSrc[iRight+2];

                if (Math.random() > 0.99998) { dOut[i]=255; dOut[i+1]=255; dOut[i+2]=255; dOut[i+3]=255; continue; }

                let pGain = exposureGain;
                if (shockStress > 0) pGain *= (1.0 + shockStress * 0.5);

                pGain *= (mode.sat || 1.0);
                
                r *= pGain * mode.r * (1 + rBias);
                g *= pGain * mode.g;
                b *= pGain * mode.b * (1 + bBias);

                if (r < activeCrush) r = 0; if (g < activeCrush) g = 0; if (b < activeCrush) b = 0;
                if (r > activeBlow) r = 255; if (g > activeBlow) g = 255; if (b > activeBlow) b = 255;

                const luma = (r+g+b)/3;
                const noise = (1 + ((255-luma)/100)) * (25 * (1 - (qVal-50)/100));
                r += (Math.random()-0.5)*noise;
                g += (Math.random()-0.5)*noise;
                b += (Math.random()-0.5)*noise;

                if (mode.con !== 1.0) {
                    r=(r-128)*mode.con+128; g=(g-128)*mode.con+128; b=(b-128)*mode.con+128; 
                }

                if (activeBanding > 1) {
                    r = Math.floor(r/activeBanding)*activeBanding;
                    g = Math.floor(g/activeBanding)*activeBanding;
                    b = Math.floor(b/activeBanding)*activeBanding;
                }

                const pIdx = i/4;
                const y = Math.floor(pIdx / w);
                if (mode.type === "phone" && (pIdx%2===0)) { r*=0.92; g*=0.92; b*=0.92; }
                if (mode.type === "vhs" && (y%2===0)) { r*=0.85; g*=0.85; b*=0.85; }

                dOut[i] = r; dOut[i+1] = g; dOut[i+2] = b; dOut[i+3] = 255;
            }

            processedC.getContext('2d').putImageData(output, 0, 0);

            const lagVal = parseInt(lagRange.value);
            
            let scanLag = mode.def.lag !== undefined ? mode.def.lag : (mode.lagMult * 35);
            scanLag = Math.max(5, Math.min(90, scanLag));

            if (scanLag > 5) {
                if (!rollingShutterBuffer) {
                    rollingShutterBuffer = document.createElement('canvas');
                    rollingShutterBuffer.width = w; rollingShutterBuffer.height = h;
                    rollingShutterBuffer.getContext('2d').drawImage(processedC, 0, 0);
                    shutterPhase = 0; 
                }
                const rsCtx = rollingShutterBuffer.getContext('2d');
                
                const scanSpeed = Math.max(8, Math.floor(h * (1.0 - (scanLag / 110))));
                
                if (shutterPhase + scanSpeed > h) {
                    const firstH = h - shutterPhase;
                    const secondH = scanSpeed - firstH;
                    
                    if (firstH > 0) {
                        rsCtx.drawImage(processedC, 0, shutterPhase, w, firstH, 0, shutterPhase, w, firstH);
                    }
                    
                    if (secondH > 0) {
                        rsCtx.drawImage(processedC, 0, 0, w, secondH, 0, 0, w, secondH);
                    }
                    
                    shutterPhase = secondH; 
                } else {
                    rsCtx.drawImage(processedC, 0, shutterPhase, w, scanSpeed, 0, shutterPhase, w, scanSpeed);
                    shutterPhase += scanSpeed;
                }
                
                pCtx.drawImage(rollingShutterBuffer, 0, 0);
            } else {
                pCtx.drawImage(processedC, 0, 0);
                rollingShutterBuffer = null; 
            }
            
            if (mode.type === "phone") {
                pCtx.fillStyle = `rgba(0,0,0,${Math.max(0, 0.08 - (qVal/600))})`;
                for(let x=0; x<w; x+=8) pCtx.fillRect(x, 0, 1, h);
                for(let y=0; y<h; y+=8) pCtx.fillRect(0, y, w, 1);
            }

            if (lagVal > 5) {
                if (!lcdDelayBuffer) { 
                    lcdDelayBuffer = document.createElement('canvas'); 
                    lcdDelayBuffer.width = w; lcdDelayBuffer.height = h; 
                }
                const dCtx = lcdDelayBuffer.getContext('2d');
                
                const curr = pCtx.getImageData(0,0,w,h).data;
                const prev = dCtx.getImageData(0,0,w,h).data;
                
                let diff = 0;
                for(let i=0; i<curr.length; i+=2000) diff += Math.abs(curr[i]-prev[i]);
                
                const motionThreshold = 8000 + (100-lagVal)*200;
                
                if (diff > motionThreshold) {
                    const splitY = Math.random() * h;
                    const shiftX = (Math.random() - 0.5) * (lagVal / 2);
                    
                    pCtx.drawImage(lcdDelayBuffer, 0, splitY, w, h-splitY, shiftX, splitY, w, h-splitY);
                    
                    pCtx.fillStyle = `rgba(${Math.random()*255}, ${Math.random()*255}, 0, 0.3)`;
                    pCtx.fillRect(0, splitY, w, 2);
                }
                
                dCtx.drawImage(processedC, 0, 0);
            }

            const blur = parseInt(blurRange.value);
            ctx.filter = blur > 0 ? `blur(${blur/4}px)` : 'none';
            
            ctx.globalAlpha = Math.max(0.1, 1.0 - (lagVal/120));
            ctx.drawImage(processedC, 0, 0);
            
            ctx.filter = 'none'; 
            
            ctx.globalAlpha = 0.4; 
            ctx.drawImage(noiseCanvas, 0, 0);
            
            ctx.globalAlpha = 1.0; 

            if (mode.type === "vhs") drawVHSOverlay();
            
            // CRITICAL: Always update recording canvas
            recCtx.drawImage(canvas, 0, 0);
        }
    }

    function drawVHSOverlay() {
        const track = parseInt(trackingRange.value);
        if (track > 0) {
            const bh = Math.max(10, track*2.5);
            const den = Math.floor(track*1.5);
            for(let i=0; i<den; i++) {
            if(Math.random()>0.3) {
                ctx.fillStyle = `rgba(255,255,255,${Math.random()*0.4})`;
                ctx.fillRect(Math.random()*w, h-bh+Math.random()*bh, Math.random()*40, 1);
            }
            }
        }
        
        ctx.fillStyle = "#eee"; ctx.font = "20px 'Courier New'"; ctx.shadowColor="black"; ctx.shadowBlur=4;
        ctx.textAlign = "left"; ctx.fillText(vhsTextIn.value, 15, 30);
        
        let dt = vhsDateIn.value.toUpperCase();
        if(dt==="AUTO") {
            const d=new Date(); const m=["JAN","FEB","MAR","APR","MAY","JUN","JUL","AUG","SEP","OCT","NOV","DEC"];
            dt=`${m[d.getMonth()]} ${('0'+d.getDate()).slice(-2)} ${d.getFullYear()}`;
        }
        ctx.fillText(dt, 15, h-15);
        
        let spd = vhsSpeedIn.value.toUpperCase();
        if(spd==="AUTO") spd=["SP","LP","SLP"][Math.floor(Date.now()/10000)%3];
        const d=new Date();
        ctx.textAlign = "right"; ctx.fillText(`${spd} ${d.getHours()}:${('0'+d.getMinutes()).slice(-2)}`, w-15, 30);
        ctx.textAlign = "left";
    }

    function handleShutter() {
        if (captureMode === 'photo') {
            if (formatSelect.value.startsWith('video/')) return showStatus("FORMAT ERROR", true);
            capturePhoto();
        } else {
            if (formatSelect.value.startsWith('image/')) return showStatus("FORMAT ERROR", true);
            isRecording ? stopRecording() : startRecording();
        }
    }

    function capturePhoto() {
        playSound('shutter');
        const link = document.createElement('a');
        const fmt = formatSelect.value === 'auto' ? 'image/jpeg' : formatSelect.value;
        const ext = fmt.includes('png') ? 'png' : 'jpg';
        
        const mode = modes[modeIndex];
        const exportW = mode.sensor ? mode.sensor.w : w * 2;
        const exportH = mode.sensor ? mode.sensor.h : h * 2;

        const upC = document.createElement('canvas');
        upC.width = exportW; upC.height = exportH;
        const upCtx = upC.getContext('2d'); upCtx.imageSmoothingEnabled=false;
        
        upCtx.drawImage(canvas, 0, 0, exportW, exportH);
        
        link.download = `${modes[modeIndex].name.replace(/\s/g,'_')}_${Date.now()}.${ext}`;
        link.href = upC.toDataURL(fmt, 0.9);
        link.click();
        
        showStatus("SAVED", false);
        setTimeout(() => {
            status.style.display='none';
            if (sourceType === 'camera') {
                stopCamera();
                resumeOverlay.style.display = 'flex';
            }
        }, 1000);
    }

    // ═══════════════════════════════════════════════════════════════
    // CRITICAL MOBILE/DESKTOP FIX - UNIVERSAL CODEC SOLUTION
    // ═══════════════════════════════════════════════════════════════
    function startRecording() {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        
        // FIXED: 25 FPS (not 30) for better mobile/CapCut compat
        const stream = recCanvas.captureStream(25);
        
        if (audioStreamDestination) {
            const at = audioStreamDestination.stream.getAudioTracks();
            if(at.length > 0) stream.addTrack(at[0]);
        }
        
        if (sourceType === 'video') video.play();

        // CRITICAL: Codec priority list for maximum compatibility
        const codecPriority = [
            'video/webm;codecs=vp8,opus',      // #1: VP8 - Most universal (Android/iPhone/Desktop)
            'video/webm;codecs=vp9,opus',      // #2: VP9 - Modern devices
            'video/webm',                      // #3: WebM default
            'video/mp4;codecs=h264,aac',       // #4: H.264 (if available)
            'video/mp4'                        // #5: MP4 fallback
        ];

        let selectedCodec = null;
        let options = { videoBitsPerSecond: 6000000 }; // 6Mbps for mobile efficiency

        // Find first supported codec
        for (const codec of codecPriority) {
            if (MediaRecorder.isTypeSupported(codec)) {
                selectedCodec = codec;
                options.mimeType = codec;
                break;
            }
        }

        console.log("📹 Selected Codec:", selectedCodec || "DEFAULT");

        try {
            mediaRecorder = new MediaRecorder(stream, selectedCodec ? options : undefined);
        } catch(e) {
            console.warn("MediaRecorder init failed, using bare defaults", e);
            mediaRecorder = new MediaRecorder(stream);
        }
        
        recordedChunks = [];
        mediaRecorder.ondataavailable = e => { 
            if(e.data && e.data.size > 0) {
                recordedChunks.push(e.data);
                console.log(`📦 Chunk ${recordedChunks.length}: ${e.data.size} bytes`);
            }
        };
        mediaRecorder.onstop = exportVideo;
        
        // CRITICAL: Start with 1 second timeslice for stable keyframes
        mediaRecorder.start(1000);
        
        isRecording = true;
        shutterBtn.classList.add("recording");
        modeSelect.disabled = true;
        
        showStatus(`REC: ${(selectedCodec || "DEFAULT").split(';')[0]}`, false);
        setTimeout(() => status.style.display = 'none', 1500);
    }

    function stopRecording() {
        shutterBtn.classList.remove("recording");
        
        // Flush final data
        setTimeout(() => {
            if(mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
            }
            isRecording = false; 
            modeSelect.disabled = false;
            
            if (sourceType === 'video') {
                video.pause();
                video.currentTime = 0;
            }
        }, 300);
    }

    function exportVideo() {
        const blob = new Blob(recordedChunks, { type: mediaRecorder.mimeType });
        
        console.log(`📊 Final blob: ${blob.size} bytes, type: ${blob.type}`);
        
        if (blob.size === 0) {
            showStatus("RECORDING FAILED (0 bytes)", true);
            if (sourceType === 'camera') {
                stopCamera();
                resumeOverlay.style.display = 'flex';
            }
            return;
        }

        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        let ext = mediaRecorder.mimeType.includes('mp4') ? 'mp4' : 'webm';
        a.href = url;
        a.download = `${modes[modeIndex].name.replace(/\s/g,'_')}_${Date.now()}.${ext}`;
        a.click();
        
        if (sourceType === 'camera') {
            stopCamera();
            resumeOverlay.style.display = 'flex';
        }
    }

    modeSelect.onchange = (e) => {
        playSound('click');
        modeIndex = parseInt(e.target.value);
        const m = modes[modeIndex];
        w = m.w; h = m.h;
        wbHuntStrength = 1.0;
        resizeBuffers();
        blurRange.value = m.def.blur; ghostRange.value = m.def.ghost;
        
        lagRange.value = m.def.lag !== undefined ? m.def.lag : (m.def.track !== undefined ? 20 : (m.lagMult * 20));
        
        contrastRange.value = m.def.contrast; qualityRange.value = m.def.quality;
        trackingRange.value = m.def.track;
        vhsControls.style.display = (m.type === "vhs") ? "flex" : "none";
        if (sourceType==='camera' && currentStream) initAudioProcessing(currentStream);
    };
    
    zoomRange.oninput = () => { zoomDisplay.innerText = (zoomRange.value/10).toFixed(1)+"x"; };
    
    modeSelect.dispatchEvent(new Event('change'));
    requestAnimationFrame(render);
</script>


</body>
</html>